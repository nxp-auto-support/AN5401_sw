/*
 * FILE NAME: main.c                    			 COPYRIGHT (c) NXP 2016
 *                                                      All Rights Reserved
 * DESCRIPTION:
 * Default configurations: RUN mode, clock source = 48MHz Fast IRC,
 * 				Core Clk = System Clk = Bus Clk = 48 MHz, Flash Clk = 24 MHz
 * This example configures part for serial secure boot process.
 * Verification data size is set first 128kB starting at memory address 0x0.
 * It also walks through the steps of how to calculate BOOT_MAC manually and
 * store it in the BOOT_MAC memory slot.
 * The BOOT_MAC is calculated manually, at run time(this program) using
 * RAM_KEY feature of CSEc
 *
 * Note: Debug/Run from RAM as program updates the system or secure flash
 *
 * PLATFORM: S32K144 MB and DC with S32DS IDE and PnE Multilink FX Debugger
 */
/*****************************************************************************/
/* REV      AUTHOR        DATE        DESCRIPTION OF CHANGE                  */
/* ---   -----------    ----------    ---------------------                  */
/* 1.0	  K Shah        25 Oct 2016  Initial Version                         */
/*****************************************************************************/

#include "S32K144.h" /* include peripheral declarations S32K144 */
#include "CSEc_functions.h"
#include "CSEc_macros.h"
#include "CSEc_keys.h"

uint32_t M1[4], M2[8], M3[4], M4[8], M5[4], M4_out[8], M5_out[4];

uint8_t compare_results(uint32_t *M4_SW, uint32_t *M4_CSEc);

int main(void)
{

	uint16_t __attribute__((unused)) csec_error = 0; //1 means No Error
	uint8_t __attribute__((unused)) result = 0; //1 means No Error
	uint32_t boot_mac[4];

	/* Step-1 Program the code/program flash with the code to be protected. */

	/* Step-2 Program BOOT_MAC_KEY into secure flash */
    calculate_M1_to_M5(M1, M2, M3, M4, M5, MASTER_ECU_KEY_VALUE, BOOT_MAC_KEY_VALUE, MASTER_ECU_KEY, BOOT_MAC_KEY, 1, 0); /* Calculate M1 to M5 in Software, Authorizing Key = Master ECU Key */
    csec_error = LOAD_KEY(M4_out, M5_out, M1, M2, M3, BOOT_MAC_KEY); /* Load the key using M1 to M3, returns M4 and M5 */
    result = compare_results(M4, M4_out); /* Compare M4 generated by SW with the M4_out returned by CSEc */

    /* Step-3 Define the secure boot flavor and the BOOT_SIZE*/
    csec_error = BOOT_DEFINE(128*1024*8, 1);

    /* ----- For Automatic BOOT_MAC generation stop execution here and reset the part twice for automatic BOOT_MAC generation and verification ----- */
    /* ----- For Manually set-up BOOT_MAC continue with the following steps ----- */

    /* Step-4 Calculate the CMAC using RAM_KEY feature of the CSEc */
    /*Load BOOT_MAC_KEY into RAM_KEY slot */
	csec_error = LOAD_RAM_KEY(BOOT_MAC_KEY_VALUE);
    /*Generate MAC for first 128kB data starting at memory address 0x0. */
    uint32_t *flash_pointer = (uint32_t *)(0x00000000);
	csec_error = MAC_SECURE_BOOT(boot_mac, flash_pointer, RAM_KEY, 128*1024*8);

	/* Step-5 Store BOOT_MAC at secure location */
    calculate_M1_to_M5(M1, M2, M3, M4, M5, MASTER_ECU_KEY_VALUE, boot_mac, MASTER_ECU_KEY, BOOT_MAC, 1, 0); /* Calculate M1 to M5 in Software, Authorizing Key = Master ECU Key */
    csec_error = LOAD_KEY(M4_out, M5_out, M1, M2, M3, BOOT_MAC); /* Load the key using M1 to M3, returns M4 and M5 */
    result = compare_results(M4, M4_out); /* Compare M4 generated by SW with the M4_out returned by CSEc */

    /* Step-7 Reset the part and attach to the debugger. See the FCSESTAT[BOK] bit.
     * If FCSESTAT[BOK]==1, the value calculated and stored is correct
     * else if FCSESTAT[BOK]==0, something went wrong
     */

    while(1);

    /* to avoid the warning message for GHS and IAR: statement is unreachable*/
#if defined (__ghs__)
#pragma ghs nowarning 111
#endif
#if defined (__ICCARM__)
#pragma diag_suppress=Pe111
#endif
	return 0;
}

/* Check both SW generated and CSEc Generated M4 */
uint8_t compare_results(uint32_t *M4_SW, uint32_t *M4_CSEc)
{
	uint8_t success=1, i;

	for(i=0;i<8;i++)
	{
		if(M4_CSEc[i] != M4_SW[i])
		{
			success = 0;
			break;
		}
	}
	return success;
}
